---
tittle: java
icon: pen-to-square
date: 2024-11-30
category:
  - JVM
timeline: true 
tag:
  - JVM
  - 垃圾回收  
  - 内存泄漏
---
# JVM
JVM主要包含以下三大功能：  
- 解释运行  
- 内存管理  
- 即时编译
<!-- more -->  
## 类加载器  
### 类的生命周期  
总共分为5个阶段：加载、连接、初始化、使用、卸载。而连接的过程又可以分为三个阶段：验证、准备、解析。  
1. 加载阶段： 类加载器在加载完类后，java虚拟机会将字节码中的信息(基本信息,常量池,字段,方法)保存在内存的方法区中,生成一个InstanceKlass对象(使用c++),保存类的所有信息,还包含多态信息.  同时,在堆中生成一份与方法区中数据类似的java.long.Class对象(使用java),作用是获取类的信息以及存储静态字段的信息。  
复制到堆的优点:只复制开发者可以访问的数据,更加安全。




## 垃圾回收 
在Java中，垃圾回收器（    Garbage Collector）负责回收不再使用的对象。垃圾回收器是一个后台线程。  
1. 可达性分析：通过一系列成为"GC Roots"的对象开始，通过引用链找到所有可以访问到的对象。GC ROOTS包含：   
- 栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI 引用的对象
2. 回收算法：    

**标记-清除算法**：产生大量内存碎片。    
**标记-整理算法**：无内存碎片。  
**复制算法**：将内存分为两块，每次只使用一块，当这一块用完，反复复制实现去除碎片。  
**分代垃圾回收**：分为新生代和老年代，新生代包含eden、survivor(包括from和to区)。  

   - Minor GC:也称为新生代GC，是针对新生代survivor区的垃圾回收。**采用复制算法**，开始全部放在伊甸区，存活下来进入form区并且年龄不断增大，from区被回收的进入to区等待下次垃圾回收，再回到from区(from和to来回互换，总比例8：1：1)。回收后进入老年区。
   - Full GC:也称为Major GC或老年代GC，是针对整个内存的垃圾回收。当老年代、元空间或者堆空间满时触发。**采用标记-整理算法**。  

3. 垃圾收集器：    

- Serial：最基本的收集器，单线程，回收效率高，需要STW。    
![alt text](image-4.png)   
- ParNew：基于Serial的并行收集器，多线程，但需要STW。适合多cpu(单cpu线程切换需要开销)
![alt text](image-5.png)  
**老年代也能并行，别的收集器**
- CMS：Concurrent Mark Sweep，并发标记-清除算法，分为四步：1.初始标记（仅仅标记GC ROOT关联的）-->2.并发标记--->3.并发清除--->4.并发复制。只有初始标记和并发标记需要STW。缺点：并发清除阶段垃圾无法清除产生浮动垃圾(浮动垃圾过多时候需要采用备胎Serial)，大量垃圾碎片。
![alt text](image-6.png)
- G1：Garbage Fisrt，默认的垃圾收集器。化整为零，将内存化为上千个部分，采用分代回收，灵活分配。
![alt text](image-7.png)