---
tittle: java
icon: pen-to-square
date: 2024-11-30
category:
  - JVM
timeline: true 
tag:
  - JVM
  - 垃圾回收  
  - 内存泄漏
---
# JVM
暂无
<!-- more -->



## 垃圾回收 
在Java中，垃圾回收器（Garbage Collector）负责回收不再使用的对象。垃圾回收器是一个后台线程。  
1. 可达性分析：通过一系列成为"GC Roots"的对象开始，通过引用链找到所有可以访问到的对象。GC ROOTS包含：   
- 栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI 引用的对象
2. 回收算法：  
**标记-清除算法**：产生大量内存碎片。  
**标记-整理算法**：无内存碎片。  
**复制算法**：将内存分为两块，每次只使用一块，当这一块用完，反复复制实现去除碎片。  
**分代垃圾回收**：分为新生代和老年代，新生代包含eden、survivor(包括from和to区)。
   - Minor GC:也称为新生代GC，是针对新生代survivor区的垃圾回收。**采用复制算法**，开始全部放在伊甸区，存活下来进入form区并且年龄不断增大，from区被回收的进入to区等待下次垃圾回收，再回到from区(from和to来回互换，总比例8：1：1)。回收后进入老年区。
   - Full GC:也称为Major GC或老年代GC，是针对整个内存的垃圾回收。当老年代、元空间或者堆空间满时触发。**采用标记-整理算法**。
3. 垃圾收集器：  
- Serial：最基本的收集器，单线程，回收效率高，需要STW。    
![alt text](image-4.png)   
- ParNew：基于Serial的并行收集器，多线程，但需要STW。适合多cpu(单cpu线程切换需要开销)
![alt text](image-5.png)  
**老年代也能并行，别的收集器**
- CMS：Concurrent Mark Sweep，并发标记-清除算法，分为四步：1.初始标记（仅仅标记GC ROOT关联的）-->2.并发标记--->3.并发清除--->4.并发复制。只有初始标记和并发标记需要STW。缺点：并发清除阶段垃圾无法清除产生浮动垃圾(浮动垃圾过多时候需要采用备胎Serial)，大量垃圾碎片。
![alt text](image-6.png)
- G1：Garbage Fisrt，默认的垃圾收集器。化整为零，将内存化为上千个部分，采用分代回收，灵活分配。
![alt text](image-7.png)