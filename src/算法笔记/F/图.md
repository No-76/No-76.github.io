---
tittle: 图
icon: pen-to-square
date: 2024-10-28
category:
  - 算法笔记
timeline: true
tag:
  - 算法
--- 
# 图
编辑中
<!-- more -->
## 搜索算法  
- DFS  

现在给出DFS迭代的模板:  

```python
def dfs(grid, i, j):
    if not 0 <= i < len(grid) or not 0 <= j < len(grid[0]) 
    : return
    grid[i][j] = '0'
    dfs(grid, i + 1, j)
    dfs(grid, i, j + 1)
    dfs(grid, i - 1, j)
    dfs(grid, i, j - 1)
```     


- BFS    
现在给出DFS迭代的模板:
```python
def bfs(grid, i, j):
    queue = [[i, j]]
    while queue:
        [i, j] = queue.pop(0)
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]):
            grid[i][j] = '0'
            queue += [[i + 1, j], [i - 1, j], [i, j - 1], [i, j + 1]]

```  
以上模板可以针对于岛屿问题    
- 岛屿数量   
- 岛屿的周长  
- 岛屿的最大面积   
- 最大人工岛 
## 并查集  
```python
class UninoFind:
    def __init__(self,size):
        self.parent = list(range(size))
    
    def find(self,p):
        if p == self.parent[p]:
            return p
        else:
            self.parent[p] = self.find(self.parent[p])
            return self.parent[p]
    
    def union(self,p1,p2):
        self.parent[self.find(p1)] = self.find(p2)
``` 
其中：  
find函数：相当于连线，如果p节点有父节点，则指向父节点来进一步搜索根节点。  
union函数：将节点p1指向节点p2。
- 时间复杂度：O(n+ClogC)，其中 n 是 equations 中的方程数量，C 是变量的总数

- 空间复杂度：O(C)。 

该模板中只用到了并查集中最简单的优化方法，即**路径压缩**，在find函数中定义，将p节点的父节点通过find函数连接到父亲的父亲，降低二叉树的高度。如果find函数调用次数够多，最终可能会出现每个节点都指向最终父节点的高度为2的树。