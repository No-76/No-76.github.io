---
tittle: 动态规划
icon: pen-to-square
date: 2024-10-13
category:
  - 算法笔记
timeline: True
tag:
  - 算法
--- 
# 动态规划
动态规划的算法核心为明确dp[i]中dp和i代表的含义。
<!-- more -->
## 数学方法求解动态规划
### 96.不同的二叉搜索树
- 题目：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
- 解法：找到的DP状态公式： 
$$G(n)=\sum_{i=1}^{n}G(i-1)\cdot G(n-i)$$
常规方法可直接根据该状态转移函数求解，现给出数学解法，其中涉及到**卡塔兰数：**  
 ![](<SmartSelect_20241014_152901_Samsung Notes.jpg>)  
直接根据该组合数求解即可。
## 背包问题
### 0-1背包  
通常应对的是数组元素单一取不放回的问题。下面有几种0-1背包的不同问题：  
- 取价值最大问题
- 分割等和数组
- 分割最相近数组
- 基于构造目标和的方案问题    

其中前三种问题可以归为一类数组求值问题，最后一种可以归为组合问题。现在分别给出不同模板：  
::: code-tabs
#shell
@tab 求值
```python
  def function(self, bagweight, weight,values):
        """
        :type bagweight: int 背包容量
        :type weight: List[int] 物品重量
        :type values: List[int] 物品价值
        """
        dp = [0] * (bagweight+1)
        dp[0] = 0
        for i in values:
            for j in range(bagweight, weight(i)-1, -1 ):
                dp[j] = max(dp[j],dp[j-i]+i)
        return dp[-1]
```
@tab 组合
```python
  def findTargetSumWays(self, nums, target):
    """
    :type nums: List[int]
    :type target: int
    """
    dp = [0] * (target_sum+1)
    dp[0] = 1
    for i in nums:
        for j in range(target_sum, i-1, -1 ):
            dp[j] += dp[j-i]
    return dp[target_sum]
```
::: 
这两中不同的问题分别有3个不同之处：  

**1.** dp初始化不同，一个是dp[0]=0一个是dp[0]=1/True，造成这个的原因是dp含义不同，一个代表的是价值，一个代表的是组合数量。
**2.** 第二层for循环中右侧区间不同，一个是物品的重量一个是物品的序号(对应价值)。
**3.** dp的状态转移函数不同，一个跟dp[j-i]+i有关，一个跟dp[j-i]有关，原因是dp含义不同。