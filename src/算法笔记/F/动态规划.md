---
tittle: 动态规划
icon: pen-to-square
date: 2024-10-13
category:
  - 算法笔记
timeline: True
tag:
  - 算法
--- 
# 动态规划
动态规划的算法核心为明确dp[i]中dp和i代表的含义。
<!-- more -->
## 数学方法求解动态规划
### 96.不同的二叉搜索树
- 题目：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
- 解法：找到的DP状态公式： 
$$G(n)=\sum_{i=1}^{n}G(i-1)\cdot G(n-i)$$
常规方法可直接根据该状态转移函数求解，现给出数学解法，其中涉及到**卡塔兰数：**  
 ![](<SmartSelect_20241014_152901_Samsung Notes.jpg>)  
直接根据该组合数求解即可。
## 背包问题
下面有几种背包的不同问题：  
- 取价值最大问题
- 分割等和数组
- 分割最相近数组
- 基于构造目标和组合方案问题
- 基于构造目标和的排列方案问题(**甚至是爬楼梯问题**)

其中前三种种问题可以归为一类数组求值问题，最后两种可以归为排列组合问题。  

这两类不同的问题分别有3个不同之处：  

**1.** dp初始化不同，一个是dp[0]=0一个是dp[0]=1/True，造成这个的原因是dp含义不同，一个代表的是价值，一个代表的是组合数量。
**2.** 第二层for循环中右侧区间不同，一个是物品的重量一个是物品的序号(对应价值)。
**3.** dp的状态转移函数不同，一个跟dp[j-i]+i有关，一个跟dp[j-i]有关，原因是dp含义不同。    

**排列组合问题中求组和要先把遍历物品，求排列要先遍历背包** 
### 代码模板 
- 0-1背包:  
不同的是单一元素不可重复选取，以下为代码模板：  
::: code-tabs
#shell
@tab 求值
```python
  dp = [0] * (bagweight+1)
  dp[0] = 0
  for i in values:
      for j in range(bagweight, weight(i)-1, -1 ):
          dp[j] = max(dp[j],dp[j-i]+i)
```
@tab 组合
```python
  dp = [0] * (target+1)
  dp[0] = 1
  for i in nums:
      for j in range(target, i-1, -1 ):
          dp[j] += dp[j-i]
```
@tab 排列
```python
  dp = [0] * (target+1)
  dp[0] = 1  
  for i in range(target, i-1, -1):  
      for j in nums:  
          if i >= j:  
              dp[i] += dp[i - j]  
```
:::   

- 完全背包:  
通常应对的是数组元素可放回重复选取的问题。模板如下：
::: code-tabs
#shell
@tab 求值
```python
  dp = [0]*(bag_weight+1)
  dp[0] = 0
  for i in range(item_nums):
      for j in range(item_weight[i],bag_weight+1):
          dp[j]=max(dp[j],dp[j-item_weight[i]]+item_values[i])
```
@tab 组合
```python
  dp = [0] * (target+1)
  dp[0] = 1
  for i in nums:
      for j in range(1, target + 1):
          dp[j] += dp[j-i]
```
@tab 排列
```python
  dp = [0] * (target+1)
  dp[0] = 1  
  for i in range(1, target + 1):  
      for j in nums:  
          if i >= j:  
              dp[i] += dp[i - j]  
```
:::
同0-1背包不同的是单一元素可以重复选取，因此循环遍历过程采取正序。
## 打家劫舍
主要有以下几类问题：
- 普通数组
- 循环数组：分别计算出去第一个和最后一个的普通数组最大值
- 树形结构：后序递归，双参数数组记录

通用转移函数:  
```python
# 普通数组
dp[i] = max(dp[i-2]+value(i),dp[i-1])
# 树形数组
return (max(left)+max(right),left[0]+right[0]+root.var)
```
## 买卖股票
主要有以下几类问题：  
- 只能买一次
- 能买无数次
- 只能买k次
- 卖出有冷却期  
解决此类问题通常使用二维数组dp[i][j],其中i代表的是第几天，k代表的是今天的状态(买入，卖出，冷却期)，dp通用模板如下：
```python
  for i in range(1, len(prices)):
      for j in range(1,2*k+1,2):
          dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]-prices[i])
          dp[i][j+1]=max(dp[i-1][j+1],dp[i-1][j]+prices[i])
```  
上面模板针对的是最多买卖k次的情况，若只能买卖1次或无数次dp的列数为2，k次的话则为2k，有冷却期则为3。
